# 受驱单摆的非线性动力学实验报告

## 1. 实验目的

简要描述本实验的主要目标：
1. 实现并比较不同数值方法求解受驱单摆方程的效果
2. 研究受驱单摆系统的共振现象
3. 分析系统在不同参数下的混沌行为

## 2. 理论背景

### 2.1 受驱单摆方程

简要介绍受驱单摆的运动方程及其物理意义：
- 方程的推导过程
- 各项参数的物理含义
- 无量纲化处理（如果使用）
![image](https://github.com/user-attachments/assets/2728c7db-1651-4a2d-9b1d-cf7dc39455d5)

### 2.2 数值方法

简要说明使用的数值方法原理：
1. 欧拉法
   - 基本原理
   - 误差阶数
   - 优缺点
将时间进行离散化，假设在时间间隔 \([t_n, t_{n + 1}]\) 内，导数近似为常数，即 \(\frac{dy}{dt}\approx\frac{y_{n + 1}-y_n}{h}\) （ h 为时间步长）。对于受驱单摆方程 \(\frac{dx}{dt}=y\) ， \(\frac{dy}{dt}=-γ''y - \sin x + F_d''\sin(\omega t)\) ，其迭代公式为：\(x_{n + 1}=x_n + h y_n\)\(y_{n + 1}=y_n + h(-γ''y_n - \sin x_n + F_d''\sin(\omega t_n))\)
误差阶数：局部截断误差为 \(O(h^2)\) ，整体截断误差为 \(O(h)\) 。优缺点：优点是原理简单，计算量小；缺点是精度较低，数值稳定性较差，对于一些快速变化或长时间积分的问题容易产生较大误差。
2. 改进欧拉法
   - 改进的思路
   - 误差阶数
   - 与简单欧拉法的比较
改进的思路：在欧拉法基础上，先使用欧拉法进行预估，得到 \(\tilde{x}_{n + 1}\) 和 \(\tilde{y}_{n + 1}\) ，然后再用预估的值计算平均斜率，进行校正。具体来说，先预估：
\(\tilde{x}_{n + 1}=x_n + h y_n\)
\(\tilde{y}_{n + 1}=y_n + h(-γ''y_n - \sin x_n + F_d''\sin(\omega t_n))\)
再校正：
\(x_{n + 1}=x_n + \frac{h}{2}(y_n + \tilde{y}_{n + 1})\)
\(y_{n + 1}=y_n + \frac{h}{2}((-γ''y_n - \sin x_n + F_d''\sin(\omega t_n))+(-γ''\tilde{y}_{n + 1} - \sin \tilde{x}_{n + 1} + F_d''\sin(\omega (t_n + h))))\)误差阶数：局部截断误差为 \(O(h^3)\) ，整体截断误差为 \(O(h^2)\) 。与简单欧拉法的比较：相比欧拉法，改进欧拉法精度更高，数值稳定性更好，但计算量也有所增加。
3. 四阶龙格-库塔法
   - 方法原理
   - 误差阶数
   - 计算效率分析
方法原理：通过在每个时间步内计算多个点的斜率，然后加权平均得到更精确的近似值。对于方程组 \(\frac{dx}{dt}=f(x,y,t)\) ， \(\frac{dy}{dt}=g(x,y,t)\) （这里 \(f(x,y,t)=y\) ， \(g(x,y,t)=-γ''y - \sin x + F_d''\sin(\omega t)\) ） ，迭代公式为：
\(k_{x1}=h f(x_n,y_n,t_n)\)
\(k_{y1}=h g(x_n,y_n,t_n)\)
\(k_{x2}=h f(x_n + \frac{k_{x1}}{2},y_n + \frac{k_{y1}}{2},t_n + \frac{h}{2})\)
\(k_{y2}=h g(x_n + \frac{k_{x1}}{2},y_n + \frac{k_{y1}}{2},t_n + \frac{h}{2})\)
\(k_{x3}=h f(x_n + \frac{k_{x2}}{2},y_n + \frac{k_{y2}}{2},t_n + \frac{h}{2})\)
\(k_{y3}=h g(x_n + \frac{k_{x2}}{2},y_n + \frac{k_{y2}}{2},t_n + \frac{h}{2})\)
\(k_{x4}=h f(x_n + k_{x3},y_n + k_{y3},t_n + h)\)
\(k_{y4}=h g(x_n + k_{x3},y_n + k_{y3},t_n + h)\)
\(x_{n + 1}=x_n + \frac{1}{6}(k_{x1} + 2k_{x2} + 2k_{x3} + k_{x4})\)
\(y_{n + 1}=y_n + \frac{1}{6}(k_{y1} + 2k_{y2} + 2k_{y3} + k_{y4})\)误差阶数：局部截断误差为 \(O(h^5)\) ，整体截断误差为 \(O(h^4)\) 。计算效率分析：精度较高，在处理复杂动力学系统时能得到较为准确的结果，但每次迭代计算量相对较大，计算时间较长。
## 3. 实验方法

### 3.1 代码实现

简要说明各个函数的实现思路：
1. `forced_pendulum_ode`函数
   - 实现要点
   - 根据无量纲化后的受驱单摆方程，接收当前时间 t 、状态变量数组 state （包含摆角 x 和角速度 y ）以及系统参数（阻尼系数 γ'' 、驱动力幅度 F_d'' 、驱动频率 ω ） ，返回状态变量的导数数组，即 [dx/dt, dy/dt] 。
   - 关键步骤说明
   - 首先从 state 数组中解包出摆角 x 和角速度 y ，然后根据方程分别计算 \(\frac{dx}{dt}\) 和 \(\frac{dy}{dt}\) 的值并返回。

2. 数值求解方法
  欧拉法实现要点：按照欧拉法的迭代公式，在循环中根据当前时间步的状态变量和时间，计算下一时间步的状态变量。每次循环更新时间、摆角和角速度的值，记录到相应数组中。
改进欧拉法实现要点：先按照欧拉法进行预估，得到临时的下一时间步状态变量，再根据预估结果计算平均斜率，进行校正，得到准确的下一时间步状态变量。同样在循环中进行迭代计算，并记录结果。
RK4 方法实现要点：依据四阶龙格 - 库塔法的迭代公式，在每个时间步内计算四个斜率值，然后通过加权平均更新状态变量。在循环中不断迭代，记录时间、摆角和角速度的变化情况。
### 3.2 实验参数

列出实验中使用的主要参数：
阻尼系数 \(γ'' = 0.5\)
驱动频率 \(\omega\) 取值范围为 \([0.1, 2]\) ，用于研究共振现象时进行扫描
驱动力幅度 \(F_d'' = 1.5\)
初始条件：摆角 \(x_0 = 0.1\) ，角速度 \(y_0 = 0\)
时间步长 \(h = 0.01\)
模拟总时间 \(T = 100\) ，用于数值方法比较和混沌行为研究
## 4. 实验结果与分析

### 4.1 数值方法比较

1. 不同方法的数值解比较
   - 插入时间序列图![image](https://github.com/user-attachments/assets/23db964e-5da6-4388-b325-9b3fd2a6f94a)

   - 分析三种方法的计算结果差异
   - 欧拉法由于其较低的精度，在处理非线性的受驱单摆系统时，无法准确捕捉系统的动力学行为，导致误差不断增大。改进欧拉法通过引入校正步骤，提高了精度，但在复杂动力学变化区域仍存在一定误差。四阶龙格 - 库塔法凭借其更高的精度阶数，能更准确地描述系统的运动。
   - 讨论数值稳定性
   - 欧拉法的数值稳定性较差，在长时间模拟或较大时间步长下容易出现发散现象。改进欧拉法的稳定性优于欧拉法，但仍不如四阶龙格 - 库塔法。四阶龙格 - 库塔法在合理的时间步长下，能够保持较好的数值稳定性，准确模拟系统的长期行为。

2. 计算效率比较
   - 比较不同方法的计算时间
   - 通过在代码中添加计时功能（如使用 Python 的 time 模块），记录三种方法在相同模拟时长和参数设置下的计算时间。发现欧拉法计算时间最短，改进欧拉法次之，四阶龙格 - 库塔法计算时间最长。
   - 分析精度和效率的权衡
   - 欧拉法虽然计算效率高，但精度低，对于需要高精度结果的受驱单摆动力学研究不适用。四阶龙格 - 库塔法精度高，但计算量大，当对精度要求极高且计算资源允许时适用。改进欧拉法在精度和效率之间取得了一定的平衡，在对精度要求不是特别苛刻，同时希望控制计算时间的情况下是一个较好的选择。

### 4.2 共振现象分析

1. 共振曲线
   - 插入幅频特性图![image](https://github.com/user-attachments/assets/d415b03d-bb10-4ff9-8160-73902c3a7f02)

   - 分析共振频率
   - 当驱动频率接近系统的固有频率时，系统发生共振，此时摆角的振幅达到最大值。这与理论预期相符，因为共振的本质就是外界驱动力频率与系统固有频率匹配，使得能量不断输入系统，导致振幅增大。
   - 讨论阻尼对共振的影响
   - 保持其他参数不变，改变阻尼系数 \(γ''\) ，重新绘制共振曲线。发现随着阻尼系数增大，共振峰的高度逐渐降低，共振频率基本不变。这是因为阻尼会消耗系统的能量，阻尼越大，能量耗散越快，在共振时系统能够积累的能量就越少，从而振幅降低。

2. 特征分析
   - 描述观察到的共振特征
   - 在共振频率附近，摆角振幅急剧增大，系统呈现出强烈的振荡行为。而且共振峰具有一定的宽度，这意味着在共振频率周围一个小范围内，系统都能表现出相对较大的振幅。
   - 与理论预期的比较
   - 实验观察到的共振特征与理论分析基本一致，验证了受驱单摆系统共振现象的理论模型。

### 4.3 混沌行为研究

1. 相空间分析
   - 插入相空间图![image](https://github.com/user-attachments/assets/605752a3-dc99-4d27-926b-cd5130bb456b)

   - 描述轨道特征
   - 混沌区域的轨道没有明显的规律，呈现出一种 “随机” 的分布，但又在一定的区域内受限。不同初始条件下的轨道在相空间中迅速分离，进一步体现了混沌系统的混沌特性。
   - 分析混沌的产生条件
   - 通过改变驱动力幅度 \(F_d''\) 和驱动频率 \(\omega\) ，发现当 \(F_d''\) 超过一定阈值且 \(\omega\) 在某些特定范围内时，系统会出现混沌行为。具体来说，随着 \(F_d''\) 增大，系统更容易进入混沌状态，而且在固有频率附近的一些频率区间内，混沌现象更为明显。

2. 参数依赖性
   - 不同参数下的系统行为
  固定阻尼系数 \(γ''\) ，改变驱动力幅度 \(F_d''\) 和驱动频率 \(\omega\) ，观察到系统从规则的周期性运动逐渐过渡到混沌运动。当 \(F_d''\) 较小时，系统表现为简单的周期运动，相空间轨迹是封闭的曲线。随着 \(F_d''\) 增大，系统先出现倍周期分岔，然后逐渐进入混沌状态。
     
   - 混沌转捩的特征
   - 在混沌转捩过程中，系统经历一系列的分岔现象，周期不断翻倍，最终进入混沌。分岔点的出现具有一定的规律性，反映了系统从有序到无序的转变过程。

## 5. 讨论

1. 数值方法的适用性
   - 各方法的优缺点
   - 欧拉法简单易用但精度低、稳定性差；改进欧拉法在精度和稳定性上有提升，但仍有限；四阶龙格 - 库塔法精度高、稳定性好，但计算量大。
   - 最佳方法的选择建议
   - 如果对计算效率要求极高，且对精度要求不苛刻，如初步探索系统大致行为时，可选用欧拉法。若希望在一定程度上兼顾精度和效率，改进欧拉法是不错的选择。当需要高精度结果，如研究共振和混沌现象的精确特征时，应选择四阶龙格 - 库塔法。

2. 物理现象的解释
  共振机理：共振是由于外界驱动力频率与系统固有频率接近，使得驱动力不断为系统提供能量，系统持续吸收能量导致振幅增大。在受驱单摆系统中，当 \(\omega\approx\omega_0\) 时，能量输入与系统内部的能量交换达到一种高效状态，从而引发共振。混沌产生的机制：受驱单摆系统的混沌源于系统的非线性特性以及参数之间的相互作用。非线性的 \(\sin\theta\) 项使得系统的运动方程具有复杂的动力学行为，当外界驱动力和阻尼等参数在一定范围内变化时，系统会出现对初始条件敏感的混沌行为。与其他物理系统的类比：受驱单摆系统的共振和混沌现象与一些其他的非线性振动系统（如杜芬振子等）有相似之处。这些系统都在特定参数条件下会出现共振增强响应以及混沌的复杂动力学行为，通过对比研究可以加深对非线性动力学普遍规律的理解。
3. 实验中遇到的问题和解决方法
   - 数值计算中的困难
   - 在使用欧拉法进行长时间模拟时，数值误差迅速积累导致结果严重偏离真实值。通过尝试减小时间步长，虽然能在一定程度上改善精度，但计算量大幅增加。最终选择使用更高精度的四阶龙格 - 库塔法来解决这个问题。
   - 参数选择的考虑
   - 在研究共振和混沌现象时，参数的选择至关重要。例如，驱动频率的扫描范围需要合理确定，范围过小可能无法找到完整的共振曲线或观察到混沌现象；范围过大则会增加计算量。通过多次尝试和参考相关文献，确定合适的参数范围，并在实验过程中根据初步结果进行微调。
   - 改进建议
   - 为了进一步提高实验结果的准确性和可靠性，可以尝试使用更高阶的数值方法或自适应时间步长算法，根据系统的变化自动调整时间步长，既能保证精度又能提高计算效率。此外，还可以结合理论分析和解析解（如果存在）来更好地验证数值结果。

## 6. 结论

总结实验的主要发现：
1. 数值方法的比较结果
   在数值方法比较中，欧拉法精度最低、稳定性最差但计算量小；改进欧拉法精度和稳定性有所提升；RK4 法精度高、稳定性好，在复杂动力学系统求解中优势明显。
3. 受驱单摆的动力学特征
  受驱单摆系统的动力学特征丰富，存在明显的共振现象，共振频率和幅度受阻尼等参数影响显著。同时，在特定参数范围内会出现混沌行为，表现为对初始条件敏感、相空间轨道复杂无规等特征。 
5. 共振和混沌现象的主要特点
共振现象是外部驱动力与系统固有频率相互作用的结果
## 7. 参考文献

列出参考的文献资料：
1. 教材和参考书
2. 相关论文
3. 网络资源

## 附录：核心代码

附上关键函数的代码实现（建议只包含最核心的部分）：

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

def forced_pendulum_ode(t, state, l, g, C, Omega):
    """
    受驱单摆的常微分方程
    state: [theta, omega]
    返回: [dtheta/dt, domega/dt]
    """
    theta, omega = state
    dtheta_dt = omega
    domega_dt = -(g/l) * np.sin(theta) - C * omega + np.sin(Omega * t)
    return [dtheta_dt, domega_dt]

def solve_pendulum(l=0.1, g=9.81, C=2, Omega=5, t_span=(0,100), y0=[0,0]):
    """
    求解受迫单摆运动方程
    返回: t, theta
    """
    # 修改：将t_eval的点数从1000增加到2000，以匹配测试用例预期
    sol = solve_ivp(
        lambda t, y: forced_pendulum_ode(t, y, l, g, C, Omega),
        t_span, y0, method='RK45', 
        dense_output=True, 
        t_eval=np.linspace(t_span[0], t_span[1], 2000)  # 修改：从1000改为2000
    )
    return sol.t, sol.y[0]

def find_resonance(l=0.1, g=9.81, C=2, Omega_range=None, t_span=(0,200), y0=[0,0]):
    """
    寻找共振频率
    返回: Omega_range, amplitudes
    """
    if Omega_range is None:
        Omega_range = np.linspace(0.1, 15, 50)
    
    amplitudes = []
    for Omega in Omega_range:
        t, theta = solve_pendulum(l, g, C, Omega, t_span, y0)
        # 取最后四分之一时间段内的振幅作为稳态振幅
        steady_state_theta = theta[int(len(theta)*3/4):]
        amplitude = (np.max(steady_state_theta) - np.min(steady_state_theta)) / 2
        amplitudes.append(amplitude)
    
    return Omega_range, amplitudes

def plot_results(t, theta, title):
    """绘制结果"""
    plt.figure(figsize=(10, 5))
    plt.plot(t, theta)
    plt.title(title)
    plt.xlabel('Time (s)')
    plt.ylabel('Angle (rad)')
    plt.grid(True)
    plt.show()

def plot_resonance_curve(Omega_range, amplitudes):
    """绘制共振曲线"""
    plt.figure(figsize=(10, 5))
    plt.plot(Omega_range, amplitudes)
    plt.title('共振曲线: 振幅 vs 驱动频率')
    plt.xlabel('驱动频率 (rad/s)')
    plt.ylabel('振幅 (rad)')
    plt.grid(True)
    plt.show()

def main():
    """主函数"""
    # 任务1: 特定参数下的数值解与可视化
    t, theta = solve_pendulum(l=0.1, g=9.81, C=2, Omega=5, t_span=(0,100), y0=[0,0])
    plot_results(t, theta, '受迫单摆运动 (Ω=5 rad/s)')
    
    # 任务2: 探究共振现象
    Omega_range, amplitudes = find_resonance(l=0.1, g=9.81, C=2, Omega_range=np.linspace(0.1, 15, 50), t_span=(0,200))
    plot_resonance_curve(Omega_range, amplitudes)
    
    # 找到共振频率并绘制共振情况
    resonance_idx = np.argmax(amplitudes)
    resonance_Omega = Omega_range[resonance_idx]
    print(f"共振频率: {resonance_Omega:.3f} rad/s")
    
    t_resonance, theta_resonance = solve_pendulum(l=0.1, g=9.81, C=2, Omega=resonance_Omega, t_span=(0,100))
    plot_results(t_resonance, theta_resonance, f'共振状态下的受迫单摆运动 (Ω={resonance_Omega:.3f} rad/s)')

if __name__ == '__main__':
    main()
```
