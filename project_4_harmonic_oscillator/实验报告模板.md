# 谐振子与非谐振子分析实验报告

## 1. 实验目的

简要说明本实验的主要目标：
1. 理解并实现简谐振子和非谐振子的数值模拟
2. 分析振幅对振动周期的影响
3. 掌握相空间分析方法
4. 比较不同类型振子的运动特征

## 2. 实验原理

### 2.1 理论基础

请简要描述：
1. 简谐振子的运动方程及其物理意义
   简谐振子的运动满足二阶微分方程 \(m\frac{d^{2}x}{dt^{2}} = -kx\)，其中 m 是振子质量，k 是劲度系数。其物理意义是振子受到的回复力与位移成正比且方向相反。令 \(\omega = \sqrt{\frac{k}{m}}\)，方程可化为 \(\frac{d^{2}x}{dt^{2}} + \omega^{2}x = 0\) 。它描述了一种理想化的振动模型，如弹簧 - 质量系统在无阻尼情况下的运动。
3. 非谐振子的运动方程及其特点
   非谐振子的运动方程没有统一标准形式，常见的如 \(m\frac{d^{2}x}{dt^{2}} = -kx - \epsilon x^{3}\)（\(\epsilon\) 为非线性系数），其特点是回复力不仅与位移一次方有关，还与位移的高次方有关，这使得运动不再是简单的正弦或余弦形式，振动表现出非线性特征 。
5. 数值求解方法（RK4）的基本原理
  四阶龙格 - 库塔（RK4）方法是一种用于数值求解常微分方程的迭代算法。它基于泰勒级数展开，通过在每个时间步内计算多个斜率（\(k_1, k_2, k_3, k_4\)）来近似解的导数，然后将这些斜率加权平均得到下一个时间步的近似解。它在精度和计算复杂度之间取得了较好的平衡，广泛应用于常微分方程的数值求解。

### 2.2 计算方法

请说明：
1. 如何将二阶微分方程转化为一阶方程组
   对于简谐振子方程 \(\frac{d^{2}x}{dt^{2}} + \omega^{2}x = 0\) ，引入新变量 \(v = \frac{dx}{dt}\) ，则可得到一阶方程组 \(\frac{dx}{dt} = v\) ，\(\frac{dv}{dt} = -\omega^{2}x\) 。类似地，对于非谐振子方程也可进行这样的转化，便于数值求解。
3. RK4方法的具体实现步骤
   对于一阶常微分方程 \(\frac{dy}{dt} = f(t, y)\) ，给定初始条件 \(y(t_0) = y_0\) ，在时间步长为 dt 时，计算过程如下：\(k_1 = dt \cdot f(t_n, y_n)\)\(k_2 = dt \cdot f(t_n + \frac{dt}{2}, y_n + \frac{k_1}{2})\)\(k_3 = dt \cdot f(t_n + \frac{dt}{2}, y_n + \frac{k_2}{2})\)\(k_4 = dt \cdot f(t_n + dt, y_n + k_3)\)\(y_{n + 1} = y_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\)\(t_{n + 1} = t_n + dt\) ，重复上述步骤求解后续时间点的 y 值。
5. 周期分析的方法
   通过数值计算得到振子位移随时间变化的数据后，利用信号处理中的峰值检测算法（如 scipy.signal.find_peaks 函数）找到位移曲线的峰值点，记录这些峰值点对应的时间，相邻峰值点时间之差即为一个周期，通过计算多个周期并求平均得到振子的振动周期。

## 3. 实验结果与分析

### 3.1 简谐振子分析

#### 3.1.1 时间演化
![屏幕截图 2025-05-28 123022](https://github.com/user-attachments/assets/5709a786-d60b-473c-8bbe-031acf140f16)
![屏幕截图 2025-05-28 123029](https://github.com/user-attachments/assets/ba1c8c61-6ccf-47c7-b3e8-9051b95fa76b)
![屏幕截图 2025-05-28 123036](https://github.com/user-attachments/assets/7bdb492e-d66b-44a2-a76d-61e7ea254ca3)
![屏幕截图 2025-05-28 123043](https://github.com/user-attachments/assets/1bb43beb-292f-4556-ab3f-24476420d4c9)

1. 插入位移随时间变化的图像
2. 分析运动特征：
   - 振幅
   - 从图像中可以看出，简谐振子的振幅在整个运动过程中保持不变，这是简谐振子的一个重要特征，反映了系统的能量守恒。
   - 周期
   - 通过周期分析方法计算得到周期，发现其周期不随时间变化，且与理论值相符。在简谐振子中，周期 \(T = \frac{2\pi}{\omega}\) ，只要 \(\omega\) 确定，周期就是固定值 。
   - 相位
   - 图像能反映出振子在不同时刻所处的振动阶段，相位体现了振子在振动过程中的相对位置，其变化具有周期性。

#### 3.1.2 振幅对周期的影响

1. 列出不同初始振幅下测得的周期数据
   ![屏幕截图 2025-05-28 122941](https://github.com/user-attachments/assets/bd079f28-a399-4789-a337-a73d56cdf487)

3. 分析振幅与周期的关系
   从数据可以看出，不同初始振幅下，简谐振子的周期基本保持不变。这体现了简谐振子的等时性特征，即简谐振子的周期与振幅无关。
4. 解释等时性特征
   从简谐振子的运动方程 \(\frac{d^{2}x}{dt^{2}} + \omega^{2}x = 0\) 可知，方程中不包含与振幅相关的项，其解为正弦或余弦函数形式，只与角频率 \(\omega\) 有关，所以周期只取决于系统本身的性质（如弹簧 - 质量系统中的质量和劲度系数），而与初始振幅无关。
   

### 3.2 非谐振子分析

#### 3.2.1 时间演化

1. 插入位移随时间变化的图像![屏幕截图 2025-05-28 122953](https://github.com/user-attachments/assets/5b8169bd-fa1b-4be3-a4e7-2bae715f6b67)

2. 分析与简谐振子的区别：
   - 波形特征
   - 非谐振子的波形不再是标准的正弦或余弦波，呈现出一定的畸变，这是由于其回复力与位移的高次方有关，导致运动的非线性。
   - 周期变化
   - 通过计算发现，非谐振子的周期会随着振幅的变化而变化，与简谐振子周期恒定不同。

#### 3.2.2 振幅对周期的影响

1. 列出不同初始振幅下测得的周期数据![屏幕截图 2025-05-28 123007](https://github.com/user-attachments/assets/e9446179-33e7-4ca6-91b1-570c7168d09f)

2. 分析振幅与周期的关系
   随着初始振幅的增大，非谐振子的周期逐渐增大，说明非谐振子的周期与振幅存在关联，振幅越大，周期越大。
4. 解释物理原因
   非谐振子的回复力包含位移的高次方项，当振幅增大时，高次方项的作用更加显著，使得振子在运动过程中的受力情况发生变化，从而影响了运动周期。

### 3.3 相空间分析

#### 3.3.1 简谐振子的相空间轨迹

1. 插入相空间图![屏幕截图 2025-05-28 123054](https://github.com/user-attachments/assets/ecc3d44b-2a8b-4771-b124-12b7192f211c)

2. 分析轨迹特征：
   - 形状
   - 简谐振子的相空间轨迹是一个椭圆，这是因为其运动方程的解是正弦和余弦函数的组合，在相空间（位移 - 速度平面）上表现为椭圆形状。
   - 对称性
   - 轨迹关于原点对称，这反映了简谐振子运动的对称性，在正负位移和速度方向上具有相同的运动特性。
   - 物理意义
   - 相空间轨迹上的每一点对应振子在某一时刻的位移和速度状态，椭圆的面积与系统的能量成正比，体现了系统能量守恒。

#### 3.3.2 非谐振子的相空间轨迹

1. 插入相空间图![屏幕截图 2025-05-28 123100](https://github.com/user-attachments/assets/fd648a0c-0eb2-4d3a-8aaa-815226c0d63d)

2. 分析轨迹特征：
   - 与简谐振子的区别
   - 非谐振子的相空间轨迹不再是规则的椭圆，可能呈现出复杂的形状，如扭曲、不规则闭合曲线等。这是由于其非线性运动导致的。
   - 形状变化的物理解释
   - 非谐振子的非线性回复力使得其在相空间中的运动不再具有简谐振子那样的简单周期性和对称性，不同振幅和初始条件下，轨迹形状差异较大，反映了系统能量和运动状态的复杂变化。

### 3.4 能量分析

1. 计算并绘制系统能量随时间的变化
   对于简谐振子，总能量 \(E = \frac{1}{2}mv^{2} + \frac{1}{2}kx^{2}\) ，通过数值计算得到不同时刻的位移 x 和速度 v ，进而计算能量并绘制能量随时间变化的图像（此处应插入图像）。对于非谐振子，能量表达式类似，但由于非线性项存在，计算和分析更为复杂。
3. 验证能量守恒定律
   在简谐振子中，从绘制的能量图像可以看出，系统能量在数值计算误差范围内基本保持不变，验证了能量守恒定律。而在非谐振子中，由于数值计算误差和非线性效应，能量可能会有一定波动，但总体上在长时间内也应满足能量守恒，只是波动情况比简谐振子更复杂。
5. 分析数值误差的来源
   数值误差主要来源于两个方面，一是数值求解方法本身的截断误差，RK4 方法虽然精度较高，但仍然存在一定的截断误差，随着时间步长的增大和计算时间的增长，误差会累积；二是计算机的舍入误差，在数值计算过程中，计算机对浮点数的存储和计算存在一定精度限制，会产生舍入误差。

## 4. 讨论

请讨论以下问题：

1. 简谐振子和非谐振子的本质区别是什么？
   简谐振子的回复力与位移成正比且方向相反，其运动方程是线性的，运动表现为标准的正弦或余弦形式，具有等时性，相空间轨迹是规则的椭圆，能量守恒且表达式简单。而非谐振子的回复力包含位移的高次方项，运动方程是非线性的，波形发生畸变，周期与振幅有关，相空间轨迹复杂，能量分析也更为复杂。
3. 数值计算中可能出现的误差来源有哪些？
   如上述能量分析中所述，主要误差来源包括数值求解方法的截断误差和计算机的舍入误差。此外，如果初始条件设置不准确，也会引入一定误差，并且在处理复杂方程和长时间段计算时，误差累积效应可能更为明显。
5. 如何改进数值方法以提高计算精度？
   可以通过减小时间步长来降低 RK4 方法的截断误差，但这会增加计算量；采用更高阶的数值求解方法，如更高阶的龙格 - 库塔方法或其他多步法等，可在一定程度上提高精度；还可以通过优化算法，如自适应步长控制，根据计算误差动态调整时间步长，既能保证精度又能控制计算量。
7. 这些振子模型在实际物理系统中的应用例子有哪些？
   简谐振子模型可用于描述很多近似线性的振动系统，如单摆（在小角度摆动时近似为简谐振子）、弹簧 - 质量系统、分子中的某些简谐振动等。非谐振子模型则可用于描述一些非线性振动现象，如强激光作用下原子分子的振动、一些复杂机械系统中的非线性振动等

## 5. 结论

总结本实验的主要发现：
1. 简谐振子的特征及验证结果
   简谐振子具有等时性，振幅不影响周期，相空间轨迹为椭圆，能量守恒。通过数值模拟和分析，验证了这些理论特征，数值计算结果与理论预期基本相符。
3. 非谐振子的特征及验证结果
   非谐振子周期与振幅相关，波形非线性，相空间轨迹复杂，能量分析更复杂。实验结果也体现了这些特性，展示了非谐振子与简谐振子在运动特征上的明显差异。
5. 数值方法的有效性分析
   使用 RK4 方法进行数值求解在一定程度上能够准确模拟振子的运动，但存在截断误差和舍入误差等问题。通过合理设置参数（如时间步长）和改进算法（如自适应步长），可以提高数值计算的有效性和精度。

## 6. 参考文献

列出实验中参考的文献资料：
1. 教材和参考书
2. 相关论文或网络资源

## 附录：代码

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks


def harmonic_oscillator_ode(state: np.ndarray, t: float, omega: float = 1.0) -> np.ndarray:
    """
    简谐振子的一阶微分方程组。

    参数:
        state: np.ndarray, 形状为(2,)的数组，包含位置x和速度v
        t: float, 当前时间（在这个系统中实际上没有使用）
        omega: float, 角频率

    返回:
        np.ndarray: 形状为(2,)的数组，包含dx/dt和dv/dt
    """
    x, v = state
    return np.array([v, -omega ** 2 * x])


def anharmonic_oscillator_ode(state: np.ndarray, t: float, omega: float = 1.0) -> np.ndarray:
    """
    非谐振子的一阶微分方程组。

    参数:
        state: np.ndarray, 形状为(2,)的数组，包含位置x和速度v
        t: float, 当前时间（在这个系统中实际上没有使用）
        omega: float, 角频率

    返回:
        np.ndarray: 形状为(2,)的数组，包含dx/dt和dv/dt
    """
    x, v = state
    return np.array([v, -omega ** 2 * x ** 3])


def rk4_step(ode_func, state, t, dt, **kwargs):
    """
    使用四阶龙格 - 库塔方法进行一步数值积分。

    参数:
        ode_func: Callable, 微分方程函数
        state: np.ndarray, 当前状态
        t: float, 当前时间
        dt: float, 时间步长
        **kwargs: 传递给ode_func的额外参数

    返回:
        np.ndarray: 下一步的状态
    """
    k1 = dt * ode_func(state, t, **kwargs)
    k2 = dt * ode_func(state + 0.5 * k1, t + 0.5 * dt, **kwargs)
    k3 = dt * ode_func(state + 0.5 * k2, t + 0.5 * dt, **kwargs)
    k4 = dt * ode_func(state + k3, t + dt, **kwargs)

    return state + (k1 + 2 * k2 + 2 * k3 + k4) / 6


def solve_ode(ode_func, initial_state, t_span, dt, **kwargs):
    """
    求解常微分方程组。

    参数:
        ode_func: Callable, 微分方程函数
        initial_state: np.ndarray, 初始状态
        t_span: Tuple[float, float], 时间范围 (t_start, t_end)
        dt: float, 时间步长
        **kwargs: 传递给ode_func的额外参数

    返回:
        Tuple[np.ndarray, np.ndarray]: (时间点数组, 状态数组)
    """
    t_start, t_end = t_span
    num_steps = int((t_end - t_start) / dt) + 1
    t = np.linspace(t_start, t_end, num_steps)
    states = np.zeros((num_steps, len(initial_state)))
    states[0] = initial_state

    for i in range(num_steps - 1):
        states[i + 1] = rk4_step(ode_func, states[i], t[i], dt, **kwargs)

    return t, states


def plot_time_evolution(t, states, title):
    """
    绘制状态随时间的演化。

    参数:
        t: np.ndarray, 时间点数组
        states: np.ndarray, 状态数组
        title: str, 图标题
    """
    plt.figure(figsize=(10, 5))
    plt.plot(t, states[:, 0], 'b-', label='位置 x')
    plt.plot(t, states[:, 1], 'r-', label='速度 v')
    plt.xlabel('时间 t')
    plt.ylabel('状态')
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
```   
